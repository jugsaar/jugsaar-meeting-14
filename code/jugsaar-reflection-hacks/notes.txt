Reflection Hacks
---
https://www.youtube.com/watch?v=GzOjCzHg5Ks

Reflection ist wie Opium... 
wenn man damit angefangen hat kann man nicht mehr aufhören

Introduction
---
Java Reflection seit 1.1

Klassen zu analysieren
Introspection auslesen von Object state
lesen / schreiben von private fields
Methoden dynamisch aufrufen
intensiv verwendet bei Serialisierung

Eigenschaften von Reflection
---
* Flexibilität
** Aufzurufende methode zur Laufzeit bestimmen

* Mächtig
** Hintergrund arbeiten wie zugriff auf private Daten
** Versteckte features nutzen

* Magic Solutions
** Man kann damit dinge tun, die man normaleweise in Java nicht machen kann
** dadurch wird man manchmal von der JVM abhängig

Demo: ThreadStopper

Gefahren von Reflection
---

* Statische Code analyse tools kommen damit nicht gut klar
* Kann zu komplexem Code führen
* Generell weniger Typsicher
* Compiler kann u.U. keine Typ-Fehler erkennen
** Etwa bei code der aus XML daten liest und daraus dynamisch Java Objects erzeugt
* Einfluss auf Performance
** Reflection in der Regel langsamer als "direkte" aufrufe
* Beschränkte möglichkeiten
** Funktioniert nicht immer in bestimmten Umgebungen (SecurityManager)

Overview Reflection package
---
IntelliJ diagram for java.lang.reflect mit java.lang.Class


Das Class Objekt
---

Sobald man einmal das Klass Objekt hat, kann man information darüber ermitteln:
* Was ist die Super-Klasse?
* Welche Interfaces werden implementiert?
* Welche Felder und Methoden sind vorhanden und welche Eigenschaften haben sie? (Sichtbarkeit)
* Analyse von Klassenhierarchien
* Welche inneren Klassen sind definiert?
* Welche Konstruktoren sind verfügbar?
* Man kann Objekte dynamisch casten (ohne Unchecked Cast warnings)

Was geht nicht über Reflection?
---
* Mit normaller Reflection gibt es keine Information zu Namen von Parametern von Methoden oder Konstrukturen
** Java 8 erlaubt unter bestimmten Umständen zugriff darauf
** Code muss mit -parameters kompiliert werden
** Wenn man classes mit debug informationen (-g) kompiliert hat kann man über bytecode analyse libs (asm, bcel) information auslesen.
* Man erhält keine Informationen über anonyme Klassen die in methoden oder klassen definiert worden sind...
* Informationen zu generischen type parametern ist nur in ausnahme fällen vorhanden
* Man kann mehr informationen über nicht-reflection tricks rausfinden

Wie man auf Members zugreift
---
* Von einer Klasse kann man auf fields, methods und constructors zugreifen.
getField(name), getDeclaredField(...)
getMethod(..), getDeclaredMethod(...)
getConstructor(...), getDeclaredConstrcutor(...)
* Der Zugriff auf private member verlangt den vorherigen Aufruf von setAccessible(true)

Wie man privaten Zustand manipuliert
---
* private Members kann man zugreifbar machen
* member.setAccessible(true)
* Setzt vorraus, das der SecurityManager dies erlaubt...

Beispiel: Manipulation von String
Demo: StringDestroyer


Beispiel: Manipulation von Integer
* Integer als oo-Wrapper von primitiven int's
* Auch Integer - Instanzen kann man manipulieren
* Java cached Integer Instanzen im Bereich von -128 to 127
* Diese Instanzen kann man über Reflection manipulieren
* IntegerCache kann via -XX:AutoBoxCacheMax= angepasst werden

Demo: IntegerHack

Demo: HashMapConfusion

Man kann über reflection den Speicherbedarf von Objekten analysieren
---
* Objekt größe generell nicht in Java definiert
* Abhängig von Plattform / JVM
* 32-Bit system: object-pointer 4 bytes, minimum object size 8 bytes
* 64-Bit system: object-pointer 8 bytes, minimum object size 16 bytes
** (mit compressed oops eingeschaltet -> 4bytes bis wirklich größere pointer adressen benötigt werden)
** java -XX:+PrintFlagsFinal -version | grep "Compress"
* Die meisten JVMs alignen Objekte in 8 byte Schritten
* Zur Abschätzung des Speicherbedarfs
** Ausgehen von Analyse-Objekt, Objektgraph traversieren
** Speicherbedarf für primitves x.SIZE z.Bsp. Integer.SIZE
* Genauere Abschätzung über Speicherbedarf via Instrumentation API

Reflection basierte Ermittlung des Speicherbedarfs
---
- Find all connected objects and measure size
- Count each object only once (IdentityHashMap)
- SKip shared objects (Strings, Boxed Primitives, Classes, Enums, etc.)

- In "C" "Abcde" was 6 bytes (5 chars + \0 terminator)
- In Java "Abcde" uses 80 bytes on a 64-bit JVM
- Unless it is an interned String, then zero...
- Empty HashMap uses 216 bytes
- List of 100 boolean values set to true
- LinkedList uses 6472 bytes
- ArrayList uses 3520 bytes
- BitSet uses 72 bytes

Instrumentation based memory counting
- Implementation specific estimate of object size...
...


Identifikation des Aufrufers
---

* StackTrace analyse
** new Throwable().getStackTrace()
** Thread.currentThread().getStackTrace()
* sun.reflect.Reflection.getCallerClass(int)
** Java 8 disabled the call to Reflection.getCallerClass(int)
* SecurityManager.getClassContext()
* Class<?> clazz = MethodHandles.lookup().lookupClass();
** zur Ermittlung des "direkten" Callers

Demo: DetectCallingClassExamples

Kosten von throwable.getStackTrace()
---
* Erzeugung eines neuen Throwable's ist teuer
* The fillInStackTrace() methode ist ein nativer Aufruf
* die eigenlichen StackTraceElement Instanzen sind leer
*
- However the actual stack trace objects are empty...
- During debugging, if you want to see the actual stack trace of
and exception, watch the getStackTrace() method
- The getStackTrace() method is even more expensive!
- However, you need to call it once per logger...

Faster method is using SecurityManager

---

Final fields

Manipulating Objects - Final field
- Final fields cannot be reassigned
- if they are bound at compile time, they will get inlined
- However, reflection my allow us to rebind them with some versions of Java
- can introduce dangerous concurrency bugs
- final fields are considered constant and can be inlined at runtime by jit compilers
- only ever do this for debugging or testing purposes

Demo: StringDestroyer
value field is final... -> we can still modify the contents of the array..
Demo: PlayingWithString

- changing static final fields
Should not be possible according to lang spec.
However, here is how you can do it (Oracle JVM)
1. find the field using normal reflection
2. find the "modifiers" field of the Field object
3. Change the "modifiers" field to not be "final"
3.1 -> via bit flags: modifiers &= ~Modifier.FINAL;
5. set the final static field.

Demo: ChangeStaticFinalFieldExample


Cost of reflection

Reflection artifacts are cached by default in the JVM...

-Dsun.reflect.noCaches=true
Demo: CostOfReflection

with caches on: time = 717ms
with caches off: time = 66171ms

cached in java.lang.Class.ReflectionData

Takes massively longer... once the cache is disabled.
Stored as SoftReference - system can get dramatically slower once SoftReferences are cleared
(and when we are already running low on memory...)


Hacking Java ENums:
http://www.jqno.nl/post/2015/02/28/hacking-java-enums/